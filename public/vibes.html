<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vibe images</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: sans-serif;
            background-color: #f5f5f5;
        }
        h1 {
            margin-top: 0px;
            margin-bottom: 30px;
            text-align: left;
            font-size: 24px; /* Desktop size */
        }
        img {
            border: 1px solid #ddd;
            border-radius: 1px;
            transition: transform 0.2s ease;
            object-fit: cover;
        }
        #container {
            position: relative;
            min-height: 100vh;
        }
        /* Add this for mobile support */
        @media (max-width: 768px) {
            body {
                padding: 10px; /* Less padding on mobile */
            }
            
            h1 {
                font-size: 20px; /* Smaller heading on mobile */
                margin-bottom: 30px; /* Less margin on mobile */
            }
            
            p, div {
                font-size: 14px; /* Smaller text on mobile */
            }
            #container img {
                position: absolute !important;
                left: 0 !important;
                top: auto !important;
                width: auto !important;
                height: auto !important;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>
        inspired by alexey guzey and sophia:
        <a href="https://guzey.com/vibes/">https://guzey.com/vibes/</a>, 
        <a href="https://girl.surgery/website_vibes/">https://girl.surgery/website_vibes/</a>
    </h1>
    <div id="container">
        <!-- Images will be placed here by JavaScript -->
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('container');
            
            // Function to shuffle array
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array; // Return the shuffled array
            }
            
            // Fetch the metadata
            fetch('/image-metadata.json')
                .then(response => response.json())
                .then(data => {
                    // Convert object to array of [filename, [width, height]] entries
                    let imageEntries = Object.entries(data);
                    imageEntries = shuffleArray(imageEntries);
                    
                    // Get container dimensions
                    const rect = container.getBoundingClientRect();
                    const containerWidth = rect.width;
                    
                    // This scaling approach uses the exact method from your reference code
                    const pairs = imageEntries.map(([filename, [w, h]]) => {
                        // Target size in pixels (600*400 = 240,000 pixels)
                        let goal_pixels = 600 * 400;
                        let actual_pixels = w * h;
                        let ratio = actual_pixels / goal_pixels;
                        
                        // Apply progressive scaling tiers exactly as in reference code
                        if (ratio > 16) {
                            // Very large images - scale down to 1/8
                            return [Math.floor(w/8), Math.floor(h/8)];
                        }
                        if (ratio > 4) {
                            // Large images - scale down to 1/4
                            return [Math.floor(w/4), Math.floor(h/4)];
                        }
                        if (ratio > 2) {
                            // Medium-large images - scale down to 1/2
                            return [Math.floor(w/2), Math.floor(h/2)];
                        }
                        if (ratio < 0.5) {
                            // Very small images - scale up to 2x
                            return [Math.floor(w*2), Math.floor(h*2)];
                        }
                        
                        // Default case - keep original size
                        return [w, h];
                    });
                    
                    // Position the images
                    let positions = [];
                    let i = 0;
                    
                    // Use an interval to place images one by one (gives a nice animation effect)
                    let interval = setInterval(() => {
                        if (i >= imageEntries.length) {
                            clearInterval(interval);
                            hideLoading();
                            return;
                        }
                        
                        let height = 600;
                        let [w, h] = pairs[i];
                        let found_place = false;
                        
                        // Find a position that doesn't overlap with existing images
                        while (!found_place) {
                            let w_max = containerWidth - w;
                            let h_max = height - h;
                            
                            // Try multiple random positions
                            for (let attempt = 0; attempt < 100; attempt++) { // More attempts (100 instead of 50)
                                let a_left = Math.random() * w_max;
                                let a_top = Math.random() * h_max;
                                
                                // Allow images to be closer together by reducing the effective size
                                // This creates some slight overlap or closer packing
                                let overlap_tolerance = 0; // Set to negative for overlapping, 0 for edge-to-edge
                                let a_right = a_left + w + overlap_tolerance;
                                let a_bottom = a_top + h + overlap_tolerance;
                                
                                let intersects = false;
                                
                                // Check for intersection with existing images
                                for (let j = 0; j < positions.length; j++) {
                                    let [b_left, b_top] = positions[j];
                                    let b_right = b_left + pairs[j][0];
                                    let b_bottom = b_top + pairs[j][1];
                                    
                                    if (a_left < b_right && a_right > b_left && a_bottom > b_top && a_top < b_bottom) {
                                        intersects = true;
                                        break;
                                    }
                                }
                                
                                if (!intersects) {
                                    found_place = true;
                                    positions.push([parseInt(a_left), parseInt(a_top)]);
                                    break;
                                }
                            }
                            
                            // If we couldn't find a place, increase the height and try again
                            if (!found_place) {
                                height += 30; // Smaller increment (30 instead of 50)
                            }
                        }
                        
                        // Create and position the image
                        let img = document.createElement("img");
                        img.src = `/images/${imageEntries[i][0]}`; // Adjust path for your file structure
                        img.width = pairs[i][0];
                        img.height = pairs[i][1];
                        img.style.width = `${pairs[i][0]}px`;
                        img.style.height = `${pairs[i][1]}px`;
                        img.style.position = "absolute";
                        img.style.top = `${positions[i][1]}px`;
                        img.style.left = `${positions[i][0]}px`;
                        img.loading = "lazy"; // Enable lazy loading
                        
                        container.appendChild(img);
                        i++;
                        
                        // If this is the last image, clear the interval
                        if (i === imageEntries.length) {
                            clearInterval(interval);
                            hideLoading();
                        }
                    }, 100); // 100ms between placing each image
                })
                .catch(error => {
                    console.error('Error loading images:', error);
                    container.innerHTML = '<p>Error loading images.</p>';
                    hideLoading();
                });

                function handleMobileLayout() {
                    const isMobile = window.innerWidth <= 768;
                    
                    if (isMobile) {
                        // Get all images
                        const images = document.querySelectorAll('#container img');
                        // Get container width
                        const containerWidth = container.clientWidth;
                        
                        // Clear existing positions
                        let positions = [];
                        
                        // Maximum width for mobile is 70% of container
                        const mobileMaxWidth = containerWidth * 0.7;
                        
                        // Reset container height
                        let maxBottom = 0;
                        
                        // Reposition all images for mobile
                        images.forEach((img, index) => {
                            // Get current dimensions
                            let width = parseInt(img.style.width);
                            let height = parseInt(img.style.height);
                            
                            // Scale down if wider than mobile max width
                            if (width > mobileMaxWidth) {
                                const scale = mobileMaxWidth / width;
                                width = Math.floor(width * scale);
                                height = Math.floor(height * scale);
                                
                                img.style.width = `${width}px`;
                                img.style.height = `${height}px`;
                            }
                            
                            // Find a position using a more vertical-focused algorithm
                            let found = false;
                            let top = 0;
                            let left = 0;
                            
                            // Try to place starting from the top, slightly randomizing horizontal position
                            while (!found) {
                                // Randomize horizontal position but keep within container
                                left = Math.floor(Math.random() * (containerWidth - width));
                                
                                // Check for overlaps
                                let overlaps = false;
                                for (const pos of positions) {
                                    const [posLeft, posTop, posWidth, posHeight] = pos;
                                    if (
                                        left < posLeft + posWidth &&
                                        left + width > posLeft &&
                                        top < posTop + posHeight &&
                                        top + height > posTop
                                    ) {
                                        overlaps = true;
                                        break;
                                    }
                                }
                                
                                if (!overlaps) {
                                    found = true;
                                } else {
                                    // If overlap, try moving down by a small increment
                                    top += 20;
                                }
                            }
                            
                            // Update image position
                            img.style.left = `${left}px`;
                            img.style.top = `${top}px`;
                            
                            // Store the position
                            positions.push([left, top, width, height]);
                            
                            // Update max bottom
                            const bottom = top + height;
                            if (bottom > maxBottom) {
                                maxBottom = bottom;
                            }
                        });
                        
                        // Update container height
                        container.style.height = `${maxBottom + 20}px`;
                    }
                }
                
                // Add window resize listener
                window.addEventListener('resize', handleMobileLayout);
        });

        window.addEventListener('load', () => {
            // This timeout allows all images to be placed first
            setTimeout(handleMobileLayout, 500);
        });
    </script>
</body>
</html>